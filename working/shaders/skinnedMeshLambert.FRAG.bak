#version 450

out vec4 FragColour;

in vec3 _Position;
in vec3 _Colour;
in vec3 _Normal;
in vec2 _TexCoords;

// Lights 
uniform vec3 ambientLightColour;
uniform vec3 sunLightDirection;
uniform vec3 sunLightColour;

// Point Lights
const int MAX_LIGHTS = 4;
uniform int numLights;
uniform vec3 PointLightColours[MAX_LIGHTS];
uniform vec3 PointLightPositions[MAX_LIGHTS];

// first texture!
uniform sampler2D diffuseTex;

// Functions
vec3 GetDiffuse(vec3 direction, vec3 colour, vec3 normal)
{
	return colour * max( 0, dot( normal, -direction ) );
}

void main()
{
	// Normalize all direction vectors
	vec3 N = normalize(_Normal);
	vec3 L = normalize(sunLightDirection);

	// calculate diffuse lighting from sunlight 
	vec3 diffuseTotal = GetDiffuse(L, sunLightColour, N);
	
	// Calculate diffuse  for all point lights
	for(int i = 0; i < numLights; i++)
	{
		vec3 direction = _Position.xyz - PointLightPositions[i]; // get direction from pixel to light (not normalized)
		float distance = length(direction);
		direction = direction / distance; // normalize

		// Attenuate the light intensity with inverese square law
		vec3 colour = PointLightColours[i] / (distance * distance);

		diffuseTotal += GetDiffuse(direction, colour, N);
	}

	float lightValue = clamp(dot(-sunLightDirection, N), 0.0, 1.0);
	lightValue += 0.3f;
	vec3 texColour = texture(diffuseTex, _TexCoords).rgb;
	FragColour = vec4(texColour * diffuseTotal, 1);	
	FragColour = vec4(_Position, 1);	
	
}